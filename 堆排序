//堆排序  时间复杂度o(nlogn)
// 堆---一种树状结构 ，优先队列也用二叉堆实现 。定义：是个二叉树，如果每个父节点都大于它的孩子结点，或者每个父节点都小于它的孩子结点，则称堆有序
//一般我们用两种操作实现堆有序，如果树中增加了结点，则用上游的方式实现，如果删除了最大值结点或者最小值结点，则先把最大值结点与数组最后一个交换，在
//采用下沉的方式  我们是从1-N开始，构造N+1的数组，父节点是k,则左右子节点分别是2K和2K+1

void swim(int k)
{   while(k>1){
      int j= k/2;
      if(less(j,k)) swap(j,k);
      k=k/2}
      
void sink(int k){
    while(2*k<=N){
    int j=2*k;
    if(less(j,j+1) j++;   //这种构造出来的有序二叉堆，左孩子肯定小于右孩子
    if(!less(k,j) break;
    swap(k,j);
    }
    
//堆排序，用堆这种树状结构进行排序，首先使用sink()来构造堆有序，然后再用下沉的方式进行sort
//构造堆有序的思想，如果子节点堆有序，则它所构成的父节点的堆也是有序的，只有一个结点肯定是堆有序的，所以我们从N/2从下到上进行构造

//对于一个已经最大值堆有序的数组，我们可以用下沉的方法，先交换1和最后N的位置swap(1,N--)，然后sink(1,N)
void heapsort(int *a,int n){
  int N=n-1;
  int k=N/2;
  //构造
  for(;k>=1;k--){  sink(a,k,N);}
  //排序
  while(N>1){
  swap(a,1,N--);
  sink(a,1,N);}
}
